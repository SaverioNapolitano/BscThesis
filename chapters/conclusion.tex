\chapter{Conclusioni}

Appare evidente come l'overhead in caso di grandi quantità di dati appaia non trascurabile e risulti nell'impossibilità pratica di utilizzare l'ORM. Tuttavia, nel caso di quantità di dati relativamente ridotte, seppur presente esso è impercettebile per l'utente. Nel caso in esame, essendo gli oggetti inseriti nel database i prodotti presenti nella dispensa di un utente, ed essendo le operazioni svolte su di essi molto semplici, è improbabile che si raggiungano numeri tali da far sperimentare all'utilizzatore dell'applicazione un evidente calo di prestazioni, mentre per il programmatore l'utilizzo di ORM semplifica notevolmente lo sviluppo, la manutenzione e il testing del codice. In particolare, l'adozione dell'ORM permette di semplificare concettualmente la visione dell'applicazione e di ragionare in termini di un unico insieme, dal momento che le tabelle del database vengono mappate, e quindi possono essere gestite, come classi Java, delegando al tool ORM l'onere di far coesistere i due ambiti e risolvere eventuali differenze o criticità, mentre in precedenza ogni funzionalità e/o cambiamento doveva essere ragionato (in fase di progettazione) e codificato (in fase di implementazione) sia in termini di puro SQL (con logica rivolta a database relazionali) che in termini di programmazione a oggetti. Il risparmio garantito dall'ORM si articola non solo in termini di tempo (con tutti i benefici, anche economici, che ne conseguono), ma soprattutto in termini di aree di interesse per lo sviluppatore, che può così concentrarsi sulla logica applicativa di alto livello senza doversi preoccupare di risolvere dettagli puramente implementativi e di basso livello. L'astrazione fornita dall'ORM permette di cambiare facilmente gli elementi concreti sottostanti (ovvero lo specifico database che si utilizza) minimizzando le modifiche necessarie per garantire la compatibilità e il funzionamento con il resto dell'applicazione: questo permette di avere un software flessibile, dinamico, pronto ad adattarsi alle esigenze che si presenteranno nel corso del tempo. Perché se un software viene usato (ed è l'obiettivo, nonché la speranza, di chi lo progetta), esso dovrà inevitabilmente cambiare, e prepararsi in anticipo per questi cambiamenti può fare la differenza fra il successo e il fallimento di un prodotto nel lungo periodo. 
